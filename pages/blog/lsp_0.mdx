---
title: LSP：让AI理解大型代码项目的关键
date: 2024/08/20
description: 探讨LSP如何成为现代开发工具的核心，以及它如何可能成为大型语言模型理解复杂代码结构的关键工具。
tags:
  - LSP
  - LLM能力扩展
  - 模仿IDE调用LSP服务
ogImage: /images/blog/LSP.webp
authorid: aower
---

> 前言: 

有时候我时常会想，为什么人类开发者可以编写维护大型代码项目，而大型语言模型（LLM）却难以胜任这项任务？

那么为什么人可以编写和维护大型代码项目呢？顺着自己的开发流程，我发现我在阅读一个新的项目的时候是这样的：

1. 通过代码高亮来区别`函数定义`、`关键字`、`流程结构`、`变量定义`等元素。
2. 通过IDE提供的强大功能，如"`Go to Definition`"、"`Go to Type Definition`"、"`Go to Implementations`"和"`Go to References`"等，快速定位和理解代码中的各个部分。
3. 重复步骤 `1 - 2`，直到被调用的函数或者变量不依赖任何未知函数或变量。
4. 运转自己的大脑，将当前函数的功能进行一个总结。
5. 跳回到引用位置。重复过程`1 - 5`。

为什么这个步骤是可行的？因为代码编写调用基本不存在交叉依赖的情况.现代编程语言和软件架构设计努力避免循环依赖。虽然在复杂系统中可能存在一些循环依赖，但良好的设计原则（如依赖倒置原则）有助于最小化这种情况，使得代码更容易理解和维护。

那么大模型能否借助外部工具完成上面的工作流呢？

**语言服务器协议（LSP）** 或许是一个可行的解决方案。

LSP最初是为了增强集成开发环境（IDE）和文本编辑器的功能而设计的。但是，如果我们能够让大型语言模型像IDE一样使用LSP，我们就可能突破当前AI理解大型代码项目的限制。以下是这个想法的几个关键点：

1. 首先大模型没有代码高亮，那它能否准确区别`函数定义`、`关键字`、`流程结构`、`变量定义`等内容呢？答案是可以的，大模型的本质是基于概率的预测系统，而编程语言的高度结构化特性（编译原理）使得这种预测变得更加可靠。

2. 那么大模型能否知道你询问代码中调用的函数的内容呢？答案肯定是不能，因为你没有发送给他相关知识，他的输出全靠猜测，根据函数命名、变量命名来猜测。如果你能将你调用的函数使用的外部变量一起发给他，这时候针对性能较好的模型，已经可以能够用准确理解代码的含义了。但是如果你的函数里面有很多的调用，被调用的函数里面又调用了很多另外的函数。这样每次手工询问都会耗费大量的时间。而且容易超过上下文窗口，并且在输入内容变多的时候，大模型的性能、推理能力也会发生下降。

为了解决以上问题，我想出了以下解决方案：

1. 通过模仿IDE调用LSP服务，大模型可以获取`函数定义`（Definition）、`类型信息`（Type Definition）、`实现细节`（Implementations）和`引用`（References）等关键信息。这解决了大模型无法主动查询信息的问题。

2. **递归理解**：我们可以设计一个递归过程，让大模型逐步深入理解代码的每个部分，类似于人类开发者的工作方式。

3. **知识压缩**：为了避免超过上下文窗口限制，我们可以让模型在理解每个函数或代码段后生成简洁的摘要。这种方法类似于人类开发者的抽象概括能力。

4. **知识图谱构建**：通过使用图数据库（如`Neo4j`）来存储项目的结构和关系信息，我们可以构建一个完整的项目知识图谱。这不仅可以优化递归调用中的重复内容，还能为后续的分析和理解提供强大的基础。

5. **语言无关性**：LSP的一大优势是其语言无关性。这意味着我们可以用相似的方法处理不同的编程语言，只需要少量的调整。

那么我们关系型数据库`Neo4j`应该如何设计存储的方式呢?

这个我没有想好通用的解决方案,我的任务仅仅是对C语言进行处理.

C语言因为没有类的概念,相对于其他语言的实现来说较为简单

对于C语言代码的GraphRAG实现，我们可以设计以下的Neo4j图数据库结构：

1. 节点类型：
   - File: 表示源代码文件
   - Function: 表示函数定义
   - Variable: 表示全局变量
   - Struct: 表示结构体定义
   - Enum: 表示枚举定义
   - Macro: 表示宏定义

2. 关系类型：
   - CONTAINS: 文件包含函数、变量、结构体等
   - CALLS: 函数调用另一个函数
   - USES: 函数使用变量或结构体
   - DEFINES: 宏定义了某个符号
   - INCLUDES: 文件包含另一个文件

3. 属性：
   - 所有节点：
     - name: 名称
     - file_path: 所在文件路径
     - line_number: 在文件中的行号
   - Function节点：
     - signature: 函数签名
     - return_type: 返回类型
     - summary: 函数功能摘要（由LLM生成）
   - Variable节点：
     - type: 变量类型
   - Struct节点：
     - members: 结构体成员列表
   - Enum节点：
     - values: 枚举值列表
   - Macro节点：
     - definition: 宏定义内容

实现步骤：

1. 代码解析：
   使用C语言的AST（抽象语法树）解析器， treeSitter，来解析源代码并提取所需信息。

2. 图数据库构建：
   将解析得到的信息存入Neo4j数据库，创建相应的节点和关系。

3. 知识图谱增强：
   使用LLM为每个Function节点生成一个简洁的功能摘要，存储在summary属性中。

4. 查询设计：
   设计一系列Cypher查询来支持常见的代码分析任务，如：
   - 查找特定函数的所有调用者
   - 追踪变量的使用情况
   - 分析函数调用图

5. GraphRAG实现：
   - 输入：开发者的问题或任务描述
   - 处理：
     a. 使用LLM分析问题，确定需要查询的信息类型
     b. 根据分析结果，生成并执行相应的Cypher查询
     c. 将查询结果返回给LLM
     d. LLM基于查询结果和原始问题生成回答或执行任务
   - 输出：生成的回答或任务结果

示例Cypher查询：

1. 查找调用特定函数的所有函数：
```cypher
MATCH (caller:Function)-[:CALLS]->(callee:Function {name: 'target_function'})
RETURN caller.name, caller.summary
```

2. 分析变量使用情况：
```cypher
MATCH (v:Variable {name: 'target_variable'})<-[:USES]-(f:Function)
RETURN f.name, f.summary
```

3. 获取函数的完整调用链：
```cypher
MATCH path = (start:Function {name: 'start_function'})-[:CALLS*]->(end:Function)
RETURN path
```

这种设计允许我们：
1. 捕获C语言代码的核心结构和关系
2. 支持复杂的代码分析查询
3. 集成LLM生成的摘要信息
4. 实现基于图的检索增强生成（GraphRAG）

通过这种方法，我们可以让LLM更好地理解大型C语言项目的结构和功能，从而提供更准确、更有洞察力的代码分析和建议。这种方法也可以扩展到其他编程语言，只需调整节点和关系的类型以适应特定语言的特性。

实现这个系统后，我们可以进行如下的交互：

1. 开发者提问："main函数中调用了哪些函数，它们各自的功能是什么？"

2. 系统处理：
   a. LLM分析问题，确定需要查找main函数的调用关系
   b. 生成并执行Cypher查询：
      ```cypher
      MATCH (main:Function {name: 'main'})-[:CALLS]->(called:Function)
      RETURN called.name, called.summary
      ```
   c. 将查询结果返回给LLM
   d. LLM基于查询结果生成回答

3. 系统输出类似于：
   "main函数调用了以下函数：
   1. initialize_system(): 初始化系统环境和配置
   2. process_input(): 处理用户输入的数据
   3. generate_output(): 根据处理结果生成输出
   4. cleanup_resources(): 清理系统资源并进行必要的收尾工作"

这种方法结合了图数据库的强大查询能力和LLM的自然语言理解与生成能力，为代码分析和理解提供了一个强大的工具。

那么现在我们开始我们的正文,我会在本篇文章对`LSP`进行一些简单的介绍,然后在后面的两篇文章中,分别实现一个 [python调用Clangd对C语言进行分析](/blog/lsp_1) 以及 [python调用gopls对Go语言进行分析](/blog/lsp_2)

## 1. LSP简介 

### 什么是LSP

语言服务器协议（Language Server Protocol，简称LSP）是一种开放的、与编程语言无关的协议，用于集成各种编程语言的智能特性到代码编辑器或集成开发环境（IDE）中。LSP定义了一套标准化的方法，使得编程语言的智能特性（如代码补全、跳转到定义、查找所有引用等）能够在不同的开发工具中统一实现。

LSP的核心思想是将语言智能分析从编辑器中分离出来，成为一个独立的服务。这种分离使得语言开发者可以为多个编辑器和IDE提供支持，而无需为每个工具单独开发插件。同时，编辑器开发者也可以轻松地集成对多种编程语言的支持，而无需深入了解每种语言的细节。

### LSP的历史和发展

LSP的概念最初由Microsoft在开发Visual Studio Code时提出。在此之前，每个IDE或编辑器都需要为支持的每种编程语言开发专门的插件或模块，这导致了大量的重复工作和维护难题。

- 2016年：Microsoft发布了LSP的初始版本，并在Visual Studio Code中实现。
- 2017年：LSP开始获得广泛关注，多个主要的IDE和编辑器开始支持LSP。
- 2018-2019年：LSP的应用范围迅速扩大，不仅限于传统的编程语言，还扩展到了配置文件、标记语言等领域。
- 2020年至今：LSP持续发展，新的特性不断被添加，如语义标记、内联值等高级功能。

如今，LSP已成为事实上的标准，被广泛应用于各种开发工具中，极大地提高了开发效率和工具的互操作性。

## 2. LSP的工作原理

### 客户端-服务器模型

LSP采用客户端-服务器架构，这种模型将语言智能功能的实现从编辑器中解耦出来：

1. 客户端（Client）：通常是代码编辑器或IDE，如Visual Studio Code、Sublime Text、Vim等。客户端负责用户界面交互和发送请求到服务器。

2. 服务器（Server）：也称为语言服务器，是一个独立的进程，负责实现特定编程语言的智能特性。服务器接收来自客户端的请求，进行处理，然后返回结果。

这种分离允许同一个语言服务器被多个不同的编辑器使用，也使得编辑器可以轻松集成对多种语言的支持。

### 通信协议概述

LSP使用JSON-RPC作为其基础通信协议。JSON-RPC是一个轻量级的远程过程调用（RPC）协议，使用JSON作为数据格式。LSP通信的基本流程如下：

1. 初始化：客户端启动语言服务器，并发送初始化请求。

2. 文件同步：客户端将打开的文件内容发送给服务器，并在文件发生变化时通知服务器。

3. 请求-响应：客户端根据用户操作发送各种请求（如代码补全、跳转定义等），服务器处理这些请求并返回结果。

4. 通知：服务器可以主动发送通知给客户端，例如报告新发现的诊断信息。

5. 关闭：当用户关闭文件或退出编辑器时，客户端通知服务器关闭连接。

LSP定义了一系列标准化的请求和通知类型，包括但不限于：

- textDocument/completion：请求代码补全建议
- textDocument/definition：请求转到定义
- textDocument/references：请求查找所有引用
- textDocument/hover：请求显示悬停信息
- textDocument/formatting：请求格式化文档

这种标准化的通信方式确保了不同语言服务器和编辑器之间的互操作性，大大简化了集成过程。

## 3. LSP的主要功能

LSP提供了一系列强大的功能，这些功能极大地提升了开发者的工作效率和代码质量。以下是LSP支持的一些核心功能：

### 代码补全

代码补全是LSP最常用和最重要的功能之一。它可以：
- 提供上下文相关的补全建议
- 支持智能补全，如根据类型信息推断可能的方法或属性
- 显示函数签名、参数信息等详细内容

例如，当开发者输入`document.`时，LSP服务器会返回`document`对象的所有可用方法和属性。

### 语法检查和诊断

LSP持续分析代码，提供实时的语法和语义错误检测：
- 标记语法错误、类型不匹配等问题
- 提供代码风格和最佳实践建议
- 支持自定义规则和配置

这些诊断信息通常以波浪线或图标的形式直接显示在编辑器中。

### 代码跳转

LSP支持多种代码导航功能：
- 跳转到定义：快速定位符号的定义位置
- 查找所有引用：列出某个符号在整个项目中的所有使用位置
- 跳转到实现：对于接口或抽象方法，可以跳转到其具体实现

这些功能大大提高了在大型代码库中的导航效率。

### 重构支持

LSP提供了多种重构功能，帮助开发者改进代码结构：
- 重命名：全局重命名变量、函数或类
- 提取方法/变量：将选中的代码块提取为新的方法或变量
- 组织导入：自动管理和优化导入语句

这些功能不仅节省时间，还有助于保持代码的一致性和可维护性。

### 其他特性

LSP还支持许多其他有用的功能：
- 代码格式化：根据预定义的规则自动格式化代码
- 文档悬停：鼠标悬停时显示符号的文档注释
- 代码折叠：智能折叠代码块
- 代码大纲：提供文件的结构概览
- 工作区符号搜索：在整个项目中搜索符号

## 4. LSP的优势

LSP的设计带来了许多显著的优势，不仅对开发者，也对工具开发商和语言设计者都有巨大好处。

### 跨编辑器和IDE的一致性

- **统一体验**：无论使用哪种编辑器，开发者都能获得一致的语言支持体验。
- **减少学习成本**：开发者在切换工具时不需要重新学习语言特性的使用方式。
- **工具选择自由**：开发者可以根据个人偏好选择编辑器，而不受语言支持的限制。

### 提高开发效率

- **即时反馈**：实时的语法检查和代码补全大大减少了编码错误。
- **快速导航**：代码跳转和查找引用功能使得在大型项目中的代码导航变得简单。
- **自动化重构**：复杂的重构操作可以安全、快速地完成。

### 降低语言工具开发成本

- **一次开发，多处使用**：语言开发者只需实现一次LSP服务器，就能支持多个编辑器。
- **专注于核心功能**：工具开发者可以专注于改进编辑器的核心功能，而不是为每种语言重复开发支持。
- **社区贡献**：开源的LSP实现可以得到广泛的社区支持和改进。

### 促进新语言的采用

- **降低采用门槛**：新的编程语言可以更容易获得广泛的工具支持。
- **快速集成**：编辑器可以快速添加对新语言的支持，只需集成相应的LSP服务器。

### 标准化和互操作性

- **开放标准**：LSP是一个开放的标准，促进了工具生态系统的健康发展。
- **互操作性**：不同供应商的工具可以无缝协作，增强了开发环境的灵活性。

LSP的这些优势使其成为现代软件开发工具链中不可或缺的一部分，极大地改善了开发者的日常工作体验，同时也为工具和语言的创新提供了更大的空间。


## 5. 常见的LSP服务器实现

随着LSP的普及，许多编程语言社区都开发了自己的LSP服务器实现。以下是一些流行的LSP服务器示例：

### JavaScript/TypeScript - TypeScript Language Server

- 由Microsoft开发，是TypeScript和JavaScript的官方LSP实现。
- 提供了强大的类型推断、代码补全和重构功能。
- 广泛用于Visual Studio Code等编辑器中。

### Python - Pylance 和 Pyright

- Pylance是Microsoft为Python开发的LSP服务器，基于Pyright。
- Pyright是一个快速的类型检查器，提供了出色的性能和准确性。
- 支持类型推断、代码补全、重构等高级功能。

### Java - Eclipse JDT Language Server

- 由Eclipse基金会开发，为Java提供全面的语言支持。
- 支持Maven、Gradle等构建工具的项目。
- 提供高级重构、代码生成等功能。

### C/C++ - clangd

- 基于LLVM/Clang编译器基础设施开发。
- 提供快速、准确的代码补全和诊断。
- 支持大型C++代码库的高效导航和重构。

### Rust - rust-analyzer

- Rust编程语言的官方LSP实现。
- 提供精确的代码补全、内联类型提示等功能。
- 支持宏展开、过程宏等Rust特有的功能。

### Go - gopls

- Go团队开发的官方Go语言服务器。
- 提供快速的代码分析和补全。
- 支持模块感知的导入组织和重构。

### Ruby - Solargraph

- 为Ruby提供智能代码补全和文档。
- 支持RuboCop集成，提供代码风格建议。
- 可以与多种编辑器和IDE集成。

这些只是众多LSP服务器实现中的一小部分。几乎所有主流编程语言都有相应的LSP服务器实现，有些语言甚至有多个选择。

## 6. 如何集成LSP服务器

集成LSP服务器到开发环境中通常涉及以下步骤：

### 1. 选择合适的LSP服务器

- 根据你使用的编程语言选择适当的LSP服务器。
- 考虑服务器的成熟度、性能和特性支持。

### 2. 安装LSP服务器

- 许多LSP服务器可以通过包管理器（如npm、pip）安装。
- 有些可能需要从源代码编译。

例如，安装TypeScript语言服务器：
```
npm install -g typescript-language-server typescript
```

### 3. 配置编辑器/IDE

- 大多数现代编辑器都内置了LSP客户端支持。
- 你需要在编辑器的设置中指定LSP服务器的路径和启动命令。

Visual Studio Code示例配置（settings.json）：
```json
{
  "languageServerExample.serverPath": "/path/to/language-server",
  "languageServerExample.trace.server": "verbose"
}
```

### 4. 启动语言服务器

- 有些编辑器会自动启动配置好的语言服务器。
- 在某些情况下，你可能需要手动启动服务器。

### 5. 验证连接

- 打开一个相关的源代码文件。
- 验证是否能使用LSP功能，如代码补全、跳转到定义等。

### 6. 自定义设置

- 许多LSP服务器允许通过配置文件进行自定义。
- 你可以调整诊断级别、格式化选项等。

示例：配置pylance（Python LSP）的设置
```json
{
  "python.analysis.typeCheckingMode": "basic",
  "python.formatting.provider": "black"
}
```

### 7. 故障排除

如果遇到问题：
- 检查编辑器的输出/日志面板，查看LSP通信日志。
- 确保LSP服务器版本与编程语言版本兼容。
- 查看服务器和编辑器的文档，了解常见问题和解决方法。

### 集成示例：在Vim中使用coc.nvim插件集成LSP

1. 安装coc.nvim插件（使用vim-plug）:
   ```vim
   Plug 'neoclide/coc.nvim', {'branch': 'release'}
   ```

2. 在Vim配置文件中添加LSP设置：
   ```vim
   " 使用Tab键触发补全
   inoremap <silent><expr> <TAB>
         \ pumvisible() ? "\<C-n>" :
         \ <SID>check_back_space() ? "\<TAB>" :
         \ coc#refresh()

   " 使用 gd 跳转到定义
   nmap <silent> gd <Plug>(coc-definition)
   " 使用 gy 跳转到类型定义
   nmap <silent> gy <Plug>(coc-type-definition)
   " 使用 gi 跳转到实现
   nmap <silent> gi <Plug>(coc-implementation)
   " 使用 gr 查找引用
   nmap <silent> gr <Plug>(coc-references)
   ```

3. 安装特定语言的LSP服务器，例如Python的：
   ```
   :CocInstall coc-pyright
   ```

通过这些步骤，你就可以在Vim中享受到LSP带来的强大功能了。

集成LSP服务器可能看起来有些复杂，但一旦设置完成，它将极大地提升你的开发效率。随着工具生态系统的不断发展，这个过程正变得越来越简单和自动化。



## 7. LSP的未来发展趋势

随着软件开发的不断演进，LSP也在持续发展以适应新的需求和技术变革。以下是一些值得关注的LSP未来发展趋势：

### 1. 人工智能和机器学习的集成

- **智能代码补全**：利用机器学习模型（如OpenAI的Codex）提供更智能、更上下文相关的代码补全建议。
- **自动化代码重构**：AI辅助的重构建议，能理解更复杂的代码结构和意图。
- **智能错误诊断**：使用ML模型分析错误模式，提供更精确的错误原因和修复建议。

### 2. 跨语言和多语言支持

- **多语言项目的无缝支持**：改进LSP以更好地处理包含多种编程语言的项目。
- **跨语言重构**：支持跨越不同语言边界的重构操作，特别是在微服务架构中。
- **统一的语义模型**：开发跨语言的通用语义模型，促进不同语言之间的互操作性。

### 3. 云原生和远程开发支持

- **云端LSP服务**：提供可扩展的云端LSP服务，支持大规模分布式开发。
- **远程开发优化**：改进LSP以更好地支持远程开发场景，减少网络延迟的影响。
- **容器化和Kubernetes集成**：简化在容器化环境中的LSP部署和管理。

### 4. 性能和可扩展性的提升

- **增量分析**：优化LSP以支持大型代码库的增量分析，提高响应速度。
- **并行处理**：利用多核处理器，实现并行化的代码分析和处理。
- **内存效率**：改进内存管理，使LSP能够更高效地处理超大规模项目。

### 5. 更广泛的工具生态系统集成

- **版本控制系统集成**：与Git等VCS更深度集成，提供智能的合并冲突解决建议。
- **持续集成/持续部署（CI/CD）集成**：LSP可以为CI/CD管道提供更丰富的代码质量信息。
- **项目管理工具集成**：将LSP的分析结果与项目管理和问题跟踪系统关联。

### 6. 安全性和合规性增强

- **实时安全漏洞检测**：集成高级安全分析工具，在编码过程中实时识别潜在的安全问题。
- **合规性检查**：自动检查代码是否符合行业标准和公司政策。
- **数据隐私分析**：帮助开发者识别和处理可能的数据隐私问题。

### 7. 更丰富的协议扩展

- **自定义语言特性支持**：使LSP更容易扩展以支持特定领域语言（DSL）的独特特性。
- **可视化编程支持**：扩展LSP以支持可视化编程环境，如图形化编程语言。
- **代码生成和转换**：增强LSP的能力，支持更复杂的代码生成和语言间转换。

## 结语

语言服务器协议（LSP）已经彻底改变了现代软件开发的面貌，为开发者提供了前所未有的工具支持和灵活性。从其诞生之初的简单概念，到如今成为连接各种编程语言和开发工具的核心协议，LSP的发展历程印证了它在软件工程中的重要地位。

随着技术的不断进步，我们可以期待LSP在未来会变得更加智能、高效、和全面。人工智能的集成将带来更智能的编码辅助，云原生技术的应用将使得开发环境更加灵活，而跨语言支持的增强将进一步打破语言之间的壁垒。

然而，技术的进步也带来了新的挑战。如何在提供丰富功能的同时保持性能，如何在云端环境中确保数据安全，以及如何使LSP更好地适应新兴的编程范式，这些都是未来LSP发展需要面对的问题。

作为开发者，了解并善用LSP不仅可以提高我们的工作效率，还能帮助我们更好地适应未来的技术变革。无论您是IDE的重度用户，还是命令行编辑器的忠实拥护者，LSP都将是您不可或缺的得力助手。

在这个软件定义世界的时代，LSP正在悄然改变着我们与代码交互的方式。它不仅是一个协议，更是连接开发者、工具和语言的桥梁，推动着整个软件开发生态系统向着更高效、更智能的方向发展。让我们拭目以待，看看LSP将如何继续塑造软件开发的未来！